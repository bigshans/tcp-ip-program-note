# 地址族与数据序列

## 3.1 分配给套接字的 IP 地址和端口号

IP (Internet Protocol) ，是为了收发网络数据而分配给计算机的值。端口号，是为了区分程序中创建的套接字而分配给套接字的需要。

### 网络地址

网络地址分为 IPv4 和 IPv6 两类。

-   IPv4 ，4 字节地址族
-   IPv6 ，16 字节地址族

IPv4 地址为一个 4 字节的标识符，一个字节有 8 位，共 32 位。
在实际使用中我们使用点分十进制记法。即将标识符每 8 位加入一个空格，再将 8 位二进制转换位十进制。

IP 地址 = 网络号 + 主机号。
分为 A 、B 、C 三类及特殊地址 D 、E 。
全 0 或全 1 都保留不用。

A 类，1 字节网络号 + 3 字节主机号，首字节范围为 0~127 。
B 类，2 字节网络号 + 2 字节主机号，首字节范围为 128~191 。
C 类，3 字节网络号 + 1 字节主机号，首字节范围为 192~223 。

### 用于区分套接字的端口号

IP 用于区分计算机，计算机中一般配有 NIC (Network Interface Card，网络接口卡) 数据传输设备。
操作系统负责把传递到内部的数据适当分配给套接字，这时就需要利用端口号。

端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将一个端口号分配给不同的套接字。
另外，端口号由 16 位构成，可分配的范围是 0-65535 。但 0-1023 是知名端口 (Well-know PORT) ，
一般分配给特定程序。虽然端口号不会重复，但 TCP 和 UDP 不会共用端口号，换而言之，TCP 和 UDP
可以同时占用一个端口号。

总是数据传输目标地址应该同时包含 IP 地址和端口号。

## 3.2 地址信息的表示

### 表示 IPv4 地址的结构体

```c
struct sockaddr_in
{
    sa_family_t sin_family;  // 地址族
    uint16_t sin_port;       // 端口号
    struct in_addr sin_addr; // 32 位 IP 地址
    char sin_zero[8];        // 不使用
}
struct in_addr
{
    in_addr_t s_addr;        // 32 位 IPv4 地址
}
```

### 结构体 sockaddr_in 的成员分析

#### sin_family

每种协议族使用的地址族均有不同。

| 地址族   | 含义                               |
| -------- | ---------------------------------- |
| AF_INET  | IPv4 网络协议中使用的地址族        |
| AF_INET6 | IPv6 网络协议中使用的地址族        |
| AF_LOCAL | 本地通信中采用的 UNIX 协议的地址族 |

其实 PF 也可以，两者没有本质区别。

#### sin_port

保存 16 位端口号，采用网络字节序保存，正常数字需要用 `htons` 转换。

#### sin_addr

保存地址的 IP 信息，也以网络字节序保存。字符串转换采用 `inet_addr` 。
类型为 `in_addr` ，但里面只有 `s_addr` ，类型位 `in_addr_t` ，可以直接视为 `in_addr_t` 。
`in_addr_t` 位 `uint32_t` ，因此只需要当作 32 位整数即可。

#### sin_zero

没用。主要用来补齐字节数，使得 `sockaddr_in` 与 `sockaddr` 保持大小一致。必须填充为 0 。

直接填充 `sockaddr` 会很麻烦。

```c
struct sockaddr
{
    sa_family_t sin_family;  // 地址族
    char        sa_data[14]; // 地址信息
}
// 14 - 2 - 4 = 8 ，所以需要补齐 8 字节
```

## 3.2 网络字节序与地址变换

### 字节序与网络字节序

CPU 向内存保存数据的方式由 2 种：

1. 大端序：高位字节存放低位地址。
2. 小端序：高位字节存放高位地址。
